// shadertype=hlsl
//========= ShiroDkxtro2's --ACROHS Ultimate Shaders Project-- ============//
//
//	Initial D.	:	04.04.2023 DMY
//	Last Change :	04.04.2023 DMY
//
//	Purpose of this File :	PBR Shader ps30, to be used on Displacements
//
//===========================================================================//

// STATIC:	"FLASHLIGHT"				"0..1"
// STATIC:	"DETAILTEXTURE"				"0..1"
// STATIC:	"EMISSION"					"0..1"
// STATIC:	"SPECIALPROPERTIES"			"0..1"
// STATIC:	"PCC"						"0..1"
// STATIC:	"PARALLAXINTERVAL"			"0..0"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"
// DYNAMIC: "FLASHLIGHTSHADOWS"         "0..1"

// Set to 0 if you are NOT on ACROHS
// DYNAMIC: "CASCADED_SHADOW"			"0..0"

// No Cubemap = No PCC
// SKIP:	$FLASHLIGHT && $PCC
// No Emission = No Emission(?)
// SKIP:	$FLASHLIGHT				&&	$EMISSION
// Selfilluminating Cloth? Bioluminescent Fabric??
// SKIP:	$EMISSION				&&	$SHEEN
// All our glowing materials are >525°C. They cannot be wet. ( Incandescence )
// Water touching the emissive materials would instantly vaporize ( and an explosion occuros )
// Therefore we removed this combo. For the safety of the player. ( Its unlikely to happen because rocks don't glow )
// SKIP:	$EMISSION				&&	$SPECIALPROPERTIES
// We require the Detail_Texture Sampler for our VectorLayering, the constants too.
// SKIP:	$SPECIALPROPERTIES		&&	$DETAILTEXTURE

// SKIP: $CASCADED_SHADOW && $FLASHLIGHT
// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)
// We don't care about flashlight depth unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTSHADOWS == 1 )

//===========================================================================//
//	Include Files ( and with them, function declarations )
//===========================================================================//

// This is used to disable features automatically.
#include "ACROHS_Defines.h"

// This IS a Shader used on BRUSHES
#define BRUSH
#define DISPLACEMENT

// This Shaders USES Normalmaps
#define NORMALTEXTURE

// This should enable Envmapping behaviour.
#define ENVMAPMODE 1

//	This has to be included first. It includes pragmas, #define's, and the register map.
#include "lux_common_ps_fxc.h"
// Lightmapping related functions
#include "lux_common_lightmapped.h"
// SelfIllum Data
#include "lux_common_selfillum.h"
// EnvMapping Data
#include "lux_common_envmap.h"
// common flashlight function.
#include "lux_common_flashlight.h"

#if PARALLAXINTERVAL
#include "lux_common_parallax.h"
#endif

#include "pbr_combined_functions.h"

// SPECIFIC TO THIS SHADER
#define			bSeamless							Bools[6]
#define			bSeamless_Secondary					Bools[7]
#define			bHasBlendModulate					Bools[8]
#define			bHasBlendModulateTransparency		Bools[9]
#define			bHammerMode							Bools[10]
sampler Sampler_BaseTexture2	: register(s1);
sampler Sampler_NormalTexture2	: register(s3);
sampler Sampler_MRAO2			: register(s7);
sampler Sampler_BlendModulate	: register(s12);

//===========================================================================//
//	Everything Vertex Shader is outputting, enters here
//===========================================================================//
struct PS_INPUT
{
    float4	BaseBaseTexCoords		:	TEXCOORD0;
	float4	NormalNormalTexCoords	:	TEXCOORD1;
	float3	WorldNormal				:	TEXCOORD2;
	float3	WorldPos				:	TEXCOORD3;
	float3	DetailCoords_ProjPosZ	:	TEXCOORD4;
	float4	LightmapTexCoord1And2	:	TEXCOORD5;
	float4	LightmapTexCoord3		:	TEXCOORD6;
	float4	BlendMaskUVW_BlendScale	:	TEXCOORD7; // .z empty right now...
	float4	SeamlessWeights			:	TEXCOORD8; // .w is Base Scale
};

float4 main(PS_INPUT i) : COLOR
{
	//	Getting our PS_INPUT... TODO/FIXME: Does this require more memory?
	//===========================================================================//
	// Integer Constants are for use with loops only...
	int iDetailBlendMode = trunc(f1DetailBlendMode);
	int iDebug			 = trunc(g_VariousControls1.x);
	float LOD			 = g_VariousControls1.y;

	// int g_Debug = trunc(DEBUG.x);

	// Always need it.
	float3 f3BaseTextureUV	= float3(i.BaseBaseTexCoords.xy, i.SeamlessWeights.w);
	float3 f3BaseTexture2UV	= float3(i.BaseBaseTexCoords.zw, i.SeamlessWeights.w);

	// Always need it.
	float3 f3NormalUV	=	float3(i.NormalNormalTexCoords.xy, i.SeamlessWeights.w);
	float3 f3Normal2UV	=	float3(i.NormalNormalTexCoords.zw, i.SeamlessWeights.w);

	float2 f2BlendMaskUV	=	i.BlendMaskUVW_BlendScale.xy; // No W actually

	#if DETAILTEXTURE
	float2 f2DetailTextureUV = i.DetailCoords_ProjPosZ.xy;
	#endif

	float	f1BlendFactor	= i.BlendMaskUVW_BlendScale.w;
	if (bHammerMode)
	{
		f1BlendFactor = 1.0f - f1BlendFactor;
	}
	float3	f3SeamlessWeights = i.SeamlessWeights.xyz;
	
	// .xyz's in case we need to pack something later
	float3 f3WorldPosition		= i.WorldPos.xyz;
	float3 f3ProjectPosition	= float3(0,0, i.DetailCoords_ProjPosZ.z); // I'm too lazy to get modify the terms down below...
	float4 f4LightmapUV1		= i.LightmapTexCoord1And2;
	float4 f4LightmapUV2		= i.LightmapTexCoord3;

	// ShiroDkxtro2 :	We do this like the PBR Shader.
	//					Tottery says this causes issues on smoothed models.
	//					However, it means we can receive more things from the Vertex Shader
	//					And I have not noticed any of such Issues.
	float3 f3FaceNormal = normalize(i.WorldNormal);
	float3 f3WorldNormal = f3FaceNormal;
    float3 f3SurfaceTangent;
    float3 f3SurfaceBase; 
    float f1FlipSign;
    float3x3 f3x3NormalBasis = Compute_Tangent_Frame(f3FaceNormal, f3WorldPosition, f3NormalUV.xy , f3SurfaceTangent, f3SurfaceBase, f1FlipSign);
	float3	f3ViewVector = normalize(g_EyePos.xyz - f3WorldPosition); // Lo

//////////////////////////////////////////////////////////////////////////////////////////
//								PARALLAX INTERVAL MAPPING								//
//////////////////////////////////////////////////////////////////////////////////////////
//	f1ParallaxHeight	
//	f1ParallaxMaxOffset	
//	f1ParallaxIntensity	
//	f1ParallaxInterval
#if PARALLAXINTERVAL
	float3 f3RelativeViewDirection	=	float3(	dot(f3ViewVector, f3SurfaceTangent),	dot(f3ViewVector, f3SurfaceBase),	dot(f3ViewVector, f3FaceNormal));

// Calculate the height at the current UV coordinate
float fCurrentHeight = tex2D(Sampler_NormalTexture, f3BaseTextureUV.xy).w * f1ParallaxIntensity;

// Calculate the parallax offset
float fParallaxOffset = 0;
int iParallaxCounter = 0;
while(iParallaxCounter < INTERVAL_COUNT)
{
	iParallaxCounter++;
    // Calculate the interval height and maximum offset
    fCurrentIntervalHeight = iParallaxCounter * fIntervalSize;
    fCurrentIntervalMaxOffset = fCurrentIntervalHeight * f1ParallaxMaxOffset / f1ParallaxHeight;

    // Calculate the intersection point of the view direction with the interval plane
    float2 f2IntersectionPoint = f3BaseTextureUV.xy + f3RelativeViewDirection.xy * fParallaxOffset;

    // Calculate the height at the intersection point
    float fIntersectionHeight = tex2D(Sampler_NormalTexture, f2IntersectionPoint.xy).w * f1ParallaxIntensity;

    // Determine if we need to continue the loop
    if (fIntersectionHeight > fCurrentIntervalHeight)
    {
        // Calculate the offset for the current interval
        float fCurrentOffset = (fIntersectionHeight - fCurrentIntervalHeight) / (fIntersectionHeight - fPreviousIntervalMaxOffset);
        fParallaxOffset += fCurrentIntervalMaxOffset * fCurrentOffset;

        // Save the previous interval's maximum offset
        fPreviousIntervalMaxOffset = fCurrentIntervalMaxOffset;
    }
    else
    {
        // Exit the loop if the intersection point is below the current interval
        break;
    }
}

// Calculate the parallax-corrected texture coordinates
float2	f2ParallaxOffset		=	f3ViewDirection.xy * fParallaxOffset;
		f3BaseTextureUV.xy		+=	f2ParallaxOffset;
		f3NormalUV.xy			+=	f2ParallaxOffset;
	#if DETAILTEXTURE
		f2DetailTextureUV.xy	+=	f2ParallaxOffset;
	#endif
#endif

	//===========================================================================//
	//	Getting the current Pixels Color from the Samplers
	//===========================================================================//
	float4	f4BaseTexture		=	float4(0,0,0,0);
	float4	f4BaseTexture2		=	float4(0,0,0,0);
	float4	f4NormalTexture		=	float4(0,0,0,0);
	float4	f4NormalTexture2	=	float4(0,0,0,0);
	float4	f4MRAO				=	float4(0,0,0,0);
	float4	f4MRAO2				=	float4(0,0,0,0);
	// Can't be seamless right now...
	// We don't want to constantly do seamless look ups... So this flag exists. This should optimise it a lot. whilst not requiring a static...
	// Also, because we have to invert for hammer... we have the most cursed section of code I have probably ever done.
	// If in Hammer we flip the samplers. However we must also make sure that we flip the tints and bias's later as well...
	if(!bSeamless)
	{
		// This is cursed. But it fixes the Hammer flipped lookup.
/*		if(bHammerMode)
		{
			f4BaseTexture2		=	tex2D(Sampler_BaseTexture, f3BaseTextureUV.xy);
			f4BaseTexture		=	tex2D(Sampler_BaseTexture2, f3BaseTexture2UV.xy);
			f4NormalTexture2	=	tex2D(Sampler_NormalTexture, f3NormalUV.xy);	
			f4NormalTexture		=	tex2D(Sampler_NormalTexture2, f3Normal2UV.xy);
			f4MRAO2				=	tex2D(Sampler_MRAO, f3BaseTextureUV.xy);
			f4MRAO				=	tex2D(Sampler_MRAO2, f3BaseTextureUV.xy);		
		}
		else */
		{
			f4BaseTexture		=	tex2D(Sampler_BaseTexture, f3BaseTextureUV.xy);
			f4BaseTexture2		=	tex2D(Sampler_BaseTexture2, f3BaseTexture2UV.xy);
			f4NormalTexture		=	tex2D(Sampler_NormalTexture, f3NormalUV.xy);	
			f4NormalTexture2	=	tex2D(Sampler_NormalTexture2, f3Normal2UV.xy);
			f4MRAO				=	tex2D(Sampler_MRAO, f3BaseTextureUV.xy);
			f4MRAO2				=	tex2D(Sampler_MRAO2, f3BaseTextureUV.xy);		
		}
	}
	else // We have seamless otherwise
	{
		// Man I hate Hammer sooooooooooooooooooooooooo much.................................
		// I simply PRAY that I can find a way to do this LESS CURSED, faster and prettier...
		if(bSeamless_Secondary)
		{
		/*	if(bHammerMode)
			{
				// These are normal...
				f4BaseTexture2		=	tex2D(Sampler_BaseTexture, f3BaseTextureUV.xy);
				f4NormalTexture2	=	tex2D(Sampler_NormalTexture, f3NormalUV.xy);
				f4MRAO2				=	tex2D(Sampler_MRAO, f3BaseTextureUV.xy);

				// These need to be seamless...
				tex2D_SeamlessSecondary(	Sampler_BaseTexture,	Sampler_NormalTexture,	Sampler_MRAO,
											f4BaseTexture,			f4NormalTexture,		f4MRAO,
											f3BaseTextureUV,		f3NormalUV,				f3SeamlessWeights	);		
			}
			else */
			{
				// These are normal...
				f4BaseTexture		=	tex2D(Sampler_BaseTexture, f3BaseTextureUV.xy);
				f4NormalTexture		=	tex2D(Sampler_NormalTexture, f3NormalUV.xy);
				f4MRAO				=	tex2D(Sampler_MRAO, f3BaseTextureUV.xy);

				// These need to be seamless...
				tex2D_SeamlessSecondary(	Sampler_BaseTexture2,	Sampler_NormalTexture2,	Sampler_MRAO2,
											f4BaseTexture2,			f4NormalTexture2,		f4MRAO2,
											f3BaseTexture2UV,		f3Normal2UV,			f3SeamlessWeights	);	
			}
		}
		else
		{
		/*
			if(bHammerMode)
			{
			tex2D_Seamless(	Sampler_BaseTexture2,	Sampler_NormalTexture2,	Sampler_MRAO2,
							Sampler_BaseTexture,	Sampler_NormalTexture,	Sampler_MRAO,
							f4BaseTexture,			f4NormalTexture,		f4MRAO,
							f4BaseTexture2,			f4NormalTexture2,		f4MRAO2,
							f3BaseTextureUV,		f3BaseTexture2UV,
							f3NormalUV,				f3Normal2UV,
							f3SeamlessWeights		);	
			}
			else */
			{
			tex2D_Seamless(	Sampler_BaseTexture,	Sampler_NormalTexture,	Sampler_MRAO,
							Sampler_BaseTexture2,	Sampler_NormalTexture2,	Sampler_MRAO2,
							f4BaseTexture,			f4NormalTexture,		f4MRAO,
							f4BaseTexture2,			f4NormalTexture2,		f4MRAO2,
							f3BaseTextureUV,		f3BaseTexture2UV,
							f3NormalUV,				f3Normal2UV,
							f3SeamlessWeights		);
			}
		}
	}

	f4NormalTexture.xyz	 =	normalize((f4NormalTexture.xyz * 2.0f - 1.0f ) * 2.0f); // Perturbed Normals
	f4NormalTexture2.xyz =	normalize((f4NormalTexture2.xyz * 2.0f - 1.0f ) * 2.0f); // Perturbed Normals

	// Set up MRAO terms :
	// There is more... Dear god...
	/*
	if(bHammerMode)
	{
			f4BaseTexture2.xyz		   *=	f3BaseTextureTint;
			f4BaseTexture.xyz		   *=	f3BaseTexture2Tint;
			f4MRAO2.x			=	clamp(f4MRAO.x	+	f1MetallicBias		,0.0f ,1.0f); // evil leveling
			f4MRAO2.y			=	clamp(f4MRAO.y	+	f1RoughnessBias		,0.0f ,1.0f); // evil leveling
			f4MRAO2.z			=	clamp(f4MRAO.z	+	f1AOBias			,0.0f ,1.0f); // evil leveling
			f4MRAO.x			=	clamp(f4MRAO2.x	+	f1Metallic2Bias		,0.0f ,1.0f); // evil leveling
			f4MRAO.y			=	clamp(f4MRAO2.y	+	f1Roughness2Bias	,0.0f ,1.0f); // evil leveling
			f4MRAO.z			=	clamp(f4MRAO2.z	+	f1AO2Bias			,0.0f ,1.0f); // evil leveling	
	}
	else */
	{
			f4BaseTexture.xyz		   *=	f3BaseTextureTint;
			f4BaseTexture2.xyz		   *=	f3BaseTexture2Tint;
			f4MRAO.x			=	clamp(f4MRAO.x	+	f1MetallicBias		,0.0f ,1.0f); // evil leveling
			f4MRAO.y			=	clamp(f4MRAO.y	+	f1RoughnessBias		,0.0f ,1.0f); // evil leveling
			f4MRAO.z			=	clamp(f4MRAO.z	+	f1AOBias			,0.0f ,1.0f); // evil leveling
			f4MRAO2.x			=	clamp(f4MRAO2.x	+	f1Metallic2Bias		,0.0f ,1.0f); // evil leveling
			f4MRAO2.y			=	clamp(f4MRAO2.y	+	f1Roughness2Bias	,0.0f ,1.0f); // evil leveling
			f4MRAO2.z			=	clamp(f4MRAO2.z	+	f1AO2Bias			,0.0f ,1.0f); // evil leveling
	}

	float	f1Metalness			=	f4MRAO.x;
	float	f1Roughness			=	f4MRAO.y;
	float	f1AmbientOcclusion	=	f4MRAO.z;
	float	f1Metalness2		=	f4MRAO2.x;
	float	f1Roughness2		=	f4MRAO2.y;
	float	f1AmbientOcclusion2	=	f4MRAO2.z;

	float3	f3Specular			=	lerp(0.01f /*f1DiElectricCoefficient.xxx*/, f4BaseTexture.rgb, f1Metalness); // ( DiElectricCoefficient  default is 0.025 now )
	float3	f3Specular2			=	lerp(0.01f /*f1DiElectricCoefficient.xxx*/, f4BaseTexture2.rgb, f1Metalness2); // ( DiElectricCoefficient  default is 0.025 now )
	float3	f3Albedo			=	f4BaseTexture.xyz * ( 1.0f - f1Metalness );
	float3	f3Albedo2			=	f4BaseTexture2.xyz * ( 1.0f - f1Metalness2 );

	// Preparing this for SPECIALPROPERTIES
	float4	f4BlendModulateTexture = float4(0,0,0,0);
	if(bHasBlendModulate)
	{
		f4BlendModulateTexture	=	tex2D(Sampler_BlendModulate, f2BlendMaskUV.xy);
		float minb = saturate(f4BlendModulateTexture.g - f4BlendModulateTexture.r);
		float maxb = saturate(f4BlendModulateTexture.g + f4BlendModulateTexture.r);
		f1BlendFactor = smoothstep(minb,maxb,f1BlendFactor);
	}

//	Wetness And Porisity modifaction for input textures.
//	Adapted from Uncharted TechArt pdf
//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
//	VectorLayer is our own implementation!
#if SPECIALPROPERTIES

// FIXME:	f4NormalTexture.xy is probably calculated incorrectly.
//			In the pdf they do float2 but this kind of implies they only want to modify two components... doesn't it?

float4	f4PropertiesTexture;
float4	f4PropertiesTexture2;
float4	f4VectorLayerTexture;
float4	f4VectorLayerTexture2;
// I think this isn't needed?
/*
if(bHammerMode) // WHEN DOES IT STOP
{
	f4PropertiesTexture2	=	tex2D(Sampler_Properties , f3BaseTextureUV.xy);
	f4PropertiesTexture		=	tex2D(Sampler_Properties2 , f3BaseTexture2UV.xy);
	f4VectorLayerTexture2	=	tex2D(Sampler_VectorLayer , f3BaseTextureUV.xy); // Uses the same sampler as the detailtexture
	f4VectorLayerTexture	=	tex2D(Sampler_VectorLayer2 , f3BaseTexture2UV.xy);
}
else
*/
{
	f4PropertiesTexture		=	tex2D(Sampler_Properties , f3BaseTextureUV.xy);
	f4PropertiesTexture2	=	tex2D(Sampler_Properties2 , f3BaseTexture2UV.xy);
	f4VectorLayerTexture	=	tex2D(Sampler_VectorLayer , f3BaseTextureUV.xy); // Uses the same sampler as the detailtexture
	f4VectorLayerTexture2	=	tex2D(Sampler_VectorLayer2 , f3BaseTexture2UV.xy);
}

// Man the amount of float definition this shader has... oof
float	f1Wetness				=	f4PropertiesTexture.x;
float	f1Porosity				=	f4PropertiesTexture.y;
float	f1VectorBlendMask		=	f4PropertiesTexture.z;
float	f1VectorLayerRoughness	=	f4PropertiesTexture.w;
float	f1Wetness2				=	f4PropertiesTexture2.x;
float	f1Porosity2				=	f4PropertiesTexture2.y;
float	f1VectorBlendMask2		=	f4PropertiesTexture2.z;
float	f1VectorLayerRoughness2	=	f4PropertiesTexture2.w;
float3	f3VectorLayerTexture	=	f4VectorLayerTexture.xyz;
float	f1VectorLayerAO			=	f4VectorLayerTexture.w;
float3	f3VectorLayerTexture2	=	f4VectorLayerTexture2.xyz;
float	f1VectorLayerAO2		=	f4VectorLayerTexture2.w;
float	f1VectorBlend			=	0.0f;
float	f1VectorBlend2			=	0.0f;
if(bVectorBlend)
{
	// BlendModulation...
	// We clamp the dot at 0. If the Normal and Desired is -1 they will return 1.0f. Otherwise only positive values will persist.
	f1VectorBlend				=	max(0.0f, dot(f3DesiredVector, f3WorldNormal)); // If they are the same. 1.0f, slowly progressing there...
	f1VectorBlend				=	smoothstep(f1VectorLayerFactor, 1.0f, f1VectorBlend); // Only 0.3 difference... Otherwise you will have a smooth falloff... Which we don't want.
	f1VectorBlend				*=	f1VectorBlendMask; // f1VectorLayerFactor = artist input

	f1VectorBlend2				=	max(0.0f, dot(f3DesiredVector2, f3WorldNormal)); // If they are the same. 1.0f, slowly progressing there...
	f1VectorBlend2				=	smoothstep(f1VectorLayerFactor2, 1.0f, f1VectorBlend2); // Only 0.3 difference... Otherwise you will have a smooth falloff... Which we don't want.
	f1VectorBlend2				*=	f1VectorBlendMask2; // f1VectorLayerFactor = artist input

	f3Albedo					=	lerp(f3Albedo			,f3VectorLayerTexture		, f1VectorBlend);
	f3Albedo2					=	lerp(f3Albedo2			,f3VectorLayerTexture2		, f1VectorBlend2);
	f1Roughness					=	lerp(f1Roughness		,f1VectorLayerRoughness		, f1VectorBlend);
	f1Roughness2				=	lerp(f1Roughness2		,f1VectorLayerRoughness2	, f1VectorBlend2);
	f3Specular					=	lerp(f3Specular			,float3(0.0f, 0.0f, 0.0f)	, f1VectorBlend);
	f3Specular2					=	lerp(f3Specular2		,float3(0.0f, 0.0f, 0.0f)	, f1VectorBlend2);
	f1AmbientOcclusion			=	lerp(f1AmbientOcclusion	,f1VectorLayerAO			, f1VectorBlend);
	f1AmbientOcclusion2			=	lerp(f1AmbientOcclusion2,f1VectorLayerAO2			, f1VectorBlend2);
}

if(bWetnessPorosity)
{
		f1Wetness				=	clamp(f1Wetness + f1WetnessBias, 0.0f , 1.0f); // evil leveling
		f1Wetness2				=	clamp(f1Wetness2 + f1WetnessBias2, 0.0f , 1.0f); // evil leveling
		// BlendModulation is applied only for terms used by both.
		// Otherwise individual wetness...ity?
		float BlendedWetness	=	lerp( f1Wetness,		f1Wetness2,		f1BlendFactor );

float3	f3SaturatedAlbedo		=	f3Albedo * f3Albedo; // Square
float3	f3SaturatedAlbedo2		=	f3Albedo2 * f3Albedo2; // Square

		// God the amount of lerps we have... Jesus f'n christ...
		// I pray this doesn't run us into some kind of pixel shader limitation...
		f3Albedo				=	lerp(f3Albedo			, f3SaturatedAlbedo	, ClampRange(f1Wetness, 0.00f, 0.35f) * f1Porosity);
		f3Albedo2				=	lerp(f3Albedo2			, f3SaturatedAlbedo2, ClampRange(f1Wetness2, 0.00f, 0.35f) * f1Porosity2);
		f1Roughness				=	lerp(f1Roughness		, 0.10f				, ClampRange(f1Wetness, 0.20f, 1.00f));
		f1Roughness2			=	lerp(f1Roughness2		, 0.10f				, ClampRange(f1Wetness2, 0.20f, 1.00f));
		f3Specular				=	lerp(f3Specular			, 0.25f				, ClampRange(f1Wetness, 0.25f, 0.50f));
		f3Specular2				=	lerp(f3Specular2		, 0.25f				, ClampRange(f1Wetness2, 0.25f, 0.50f));
		f1AmbientOcclusion		=	lerp(f1AmbientOcclusion	, 1.00f				, ClampRange(f1Wetness, 0.45f, 0.95f));		
		f1AmbientOcclusion2		=	lerp(f1AmbientOcclusion2, 1.00f				, ClampRange(f1Wetness2, 0.45f, 0.95f));
												
		f4NormalTexture.xy		=	lerp(f4NormalTexture.xy	, float2(0.5f, 0.5f), ClampRange(f1Wetness, 0.45f, 0.95f));
		f4NormalTexture2.xy		=	lerp(f4NormalTexture.xy	, float2(0.5f, 0.5f), ClampRange(f1Wetness2, 0.45f, 0.95f));
		f3WorldNormal			=	lerp(f3WorldNormal		, float3(0, 0, 1.0f), ClampRange(BlendedWetness, 0.98f, 1.00f));
		f3WorldNormal			=	normalize(f3WorldNormal);
}
#endif

	//==============================================================================================================//
	// We want to do the below as late as possible so we can modify everything with wetness/porosity first above.
	//==============================================================================================================//

	// ACTUALLY LERP THEM TOGETHER **EVEN MORE LERPS??!?!** ~+ cries in a corner +~
	f3Albedo			=	lerp(f3Albedo,				f3Albedo2,				f1BlendFactor);
	f1Roughness			=	lerp(f1Roughness,			f1Roughness2,			f1BlendFactor);
	f3Specular			=	lerp(f3Specular,			f3Specular2,			f1BlendFactor);
	f1AmbientOcclusion	=	lerp(f1AmbientOcclusion,	f1AmbientOcclusion2,	f1BlendFactor);
	f4NormalTexture		=	lerp(f4NormalTexture,		f4NormalTexture2,		f1BlendFactor);

#if DETAILTEXTURE
	float4	f4DetailTexture	= tex2D(Sampler_DetailTexture, f2DetailTextureUV.xy);
	f4DetailTexture.xyz *= f3DetailTextureTint;
	f3Albedo = TextureCombine( float4(f3Albedo, f4BaseTexture.w), f4DetailTexture, iDetailBlendMode, f1DetailBlendFactor ).xyz;
#endif

	//===========================================================================//
	//	BlendModulation
	//===========================================================================//

	// Important to use WorldNormal. We want actual direction of the surface, and not fake one.
		float	f1NdotV				=	max( dot( f3WorldNormal, f3ViewVector ), 0.0f ); // cosLo

	//	AO Fresnel. ( AO should not appear when viewing from the front. )
	//	AO happens when a pixel is occluded by nearby geometry. This is not the case when you look at it from the front.
	//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
			f1AmbientOcclusion	=	lerp(1.0f, f1AmbientOcclusion, f1NdotV);
	float3	f3NormalTexture		=	f4NormalTexture.xyz; // Already perturbed
	// Merge Facenormal and Normalmap together for reflection vector etc.
			f3FaceNormal		=	normalize(mul(f3NormalTexture, f3x3NormalBasis));

    // Prepare ambient and direct
    float3 f3AmbientLighting = 0.0f;
    float3 f3DirectLighting = 0.0f;

#if !FLASHLIGHT
	//	We do cubemap ambient cubes because there is no ambient cubes for static props. That way we could also use this on brushes and make things look somewhat consistent.
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, Sampler_EnvironmentMap);

	// Use FaceNormal and this will doom the resulting lightmap.
	float3 f3LightMap = LUX_BumpedLightmap(f3NormalTexture, f4LightmapUV1, f4LightmapUV2);

	f3DirectLighting = StaticUnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3LightMap);
	f3DirectLighting *= f1AmbientOcclusion;

	// A better reflection vector...
	float3 f3ReflectionVector = 2.0 * f1NdotV * f3FaceNormal - f3ViewVector;

#if PCC

	//	Parallax correction (2_0b and beyond)
	//	Adapted from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/
	float3 f3PositionLS = mul(float4(f3WorldPosition, 1), f4x3CorrectionMatrix);
	
	//	Not Tottery Magic Code
	//	float3	f3RayLS = mul(f3ReflectionVector, (float3x3) f4x3CorrectionMatrix);
	//	Tottery's Magic Code
	//	TODO: This uses a f4x3 but it should be using a float f3x3
	//	TODO: Stuff pos in the alpha if it isn't actually being used anyways.
	float3	f3RayLS = mul(float4(f3ReflectionVector, 0.0f), f4x3CorrectionMatrix);
	float3	f3FirstPlaneIntersect = (float3(1.0f, 1.0f, 1.0f) - f3PositionLS) / f3RayLS;
	float3	f3SecondPlaneIntersect = (-f3PositionLS) / f3RayLS;
	float3	f3FurthestPlane = max(f3FirstPlaneIntersect, f3SecondPlaneIntersect);
	float	f1Distance = min(f3FurthestPlane.x, min(f3FurthestPlane.y, f3FurthestPlane.z));
	
	// Use distance in WS directly to recover intersection
	float3 f3IntersectPositionWS = f3WorldPosition + f3ReflectionVector * f1Distance;
	
	f3ReflectionVector = f3IntersectPositionWS - f3CubeMapPos;
	
	// Lookup the Texture using f3ReflectionVector as the VectorUV for the Cubemap. ( which pixel it points at)
	float4 f4SpecularUV = float4(f3ReflectionVector, f1Roughness * LOD);
	float3 f3SpecularLookUp = ENV_MAP_SCALE * texCUBElod(Sampler_EnvironmentMap, f4SpecularUV).xyz;

#else

	// Lookup the Texture using f3ReflectionVector as the VectorUV for the Cubemap. ( which pixel it points at)
    float4 f4SpecularUV = float4(f3ReflectionVector, f1Roughness * LOD);
	float3 f3SpecularLookUp = ENV_MAP_SCALE * texCUBElod(Sampler_EnvironmentMap, f4SpecularUV).xyz;
#endif

	f3SpecularLookUp *= f3EnvMapTint;
	float3 f3LookupHighSaturated = f3SpecularLookUp * f3SpecularLookUp;
	f3SpecularLookUp = lerp( f3SpecularLookUp, f3LookupHighSaturated, f1EnvMapContrast );

	// If you are curious this has to do with perception.
	float3 f3DesaturatedCubemap = dot( f3SpecularLookUp, float3( 0.299f, 0.587f, 0.114f ) );
	f3SpecularLookUp = lerp( f3DesaturatedCubemap, f3SpecularLookUp, f3EnvMapSaturation );

	

    float3 f3LookupLow = AmbientLight(f3SpecularLookUp, EnvAmbientCube);
    float3 f3SpecularIrradiance = lerp(f3SpecularLookUp, f3LookupLow, f1Roughness * f1Roughness);
    float3 f3SpecularIBL = f3SpecularIrradiance * EnvBRDFApprox(f3Specular, f1Roughness, f1NdotV);

	f3SpecularIBL = lerp(f3SpecularIBL, f3SpecularIBL * saturate(f3DirectLighting), f1EnvMapLightScale);

    f3AmbientLighting = f3SpecularIBL * f1AmbientOcclusion;

    // End ambient

#else  // End direct

// TODO: Pack this into a neat little function inside our Header.

	float4 f4FlashlightSpacePosition = mul(float4(i.WorldPos.xyz, 1.0), g_FlashlightWorldToTexture);
	clip(f4FlashlightSpacePosition.w);

	// Flashlight position is same as player position...
	float3 f3ProjCoords = f4FlashlightSpacePosition.xyz / f4FlashlightSpacePosition.w;

	float3 f3FlashlightColor = tex2D(Sampler_FlashlightCookie, f3ProjCoords.xy).xyz; // Sampler_FlashlightCookie

	// Removed some ifdef for Shadermodels here.
	f3FlashlightColor *= cFlashlightColor.xyz;

	float3	f3Delta = g_FlashlightPos.xyz - i.WorldPos.xyz;
	float3	f3L = normalize(f3Delta);
	float	f1DistSquared = dot(f3Delta, f3Delta);
	float	f1Dist = sqrt(f1DistSquared);

	float	f1FarZ = g_FlashlightAttenuationFactors.w;
	float	f1EndFalloffFactor = RemapValClamped(f1Dist, f1FarZ, 0.6f * f1FarZ, 0.0f, 1.0f);

	// Attenuation for light and to fade out shadow over distance
	float	f1Atten = saturate(dot(g_FlashlightAttenuationFactors.xyz, float3(1.0f, 1.0f / f1Dist, 1.0f / f1DistSquared)));

#if FLASHLIGHTSHADOWS
		// TODO: Figure out if this was set to 2048 because of forced Shadow Resolution or because its good values...
		float f1Shadow = LUX_DoShadowNvidiaPCF5x5Gaussian(f3ProjCoords, float2(1.0 / 2048.0, 1.0 / 2048.0));
		float f1Attenuated = lerp(saturate(f1Shadow), 1.0f, g_ShadowTweaks.y);	// Blend between fully attenuated and not attenuated
		
		f1Shadow = saturate(lerp(f1Attenuated, f1Shadow, f1Atten));	// Blend between shadow and above, according to light attenuation
		f3FlashlightColor *= f1Shadow;									// Shadow term
#endif

	float3 f3DiffuseLighting = f1Atten;
	f3DiffuseLighting *= saturate(dot(f3L.xyz, f3FaceNormal)); // + f1FlashlightNoLambertValue); // NoLambertValue is either 0 or 2
	
	f3DiffuseLighting *= f3FlashlightColor;
	f3DiffuseLighting *= f1EndFalloffFactor;

	f3DirectLighting  += UnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3L, f3DiffuseLighting);

#endif // !FLASHLIGHT

    float f1FogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, f3WorldPosition, f3ProjectPosition.z);

#if !FLASHLIGHT
#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    float f1Alpha = f1FogFactor;
#else
    float f1Alpha = f4BaseTexture.a;
#endif // WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
#else
    float f1Alpha = 0.0f;
#endif // !FLASHLIGHT

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

	// Combine the results
	float4 f4Result = float4(f3DirectLighting + f3AmbientLighting ,f1Alpha);

#if DETAILTEXTURE
	f4Result.xyz = TextureCombinePostLighting( f4Result, f4DetailTexture, iDetailBlendMode, f1DetailBlendFactor ); // $detail, $detailblendmode $detailblendfactor
#endif

#if EMISSION
	f4Result.xyz += tex2D(Sampler_Emission, f3BaseTextureUV.xy).xyz * f3EmissionTint;
#endif

    return FinalOutput(f4Result, f1FogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, f3ProjectPosition.z);
}