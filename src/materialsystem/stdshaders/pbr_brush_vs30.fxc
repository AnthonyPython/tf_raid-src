//========= ShiroDkxtro2's --ACROHS Ultimate Shaders Project-- ============//
//
//	Initial D.	:	21.03.2023 DMY
//	Last Change :	21.03.2023 DMY
//
//	Purpose of this File :	VertexShader for pbr vs30, to be used on Brushes
//
//===========================================================================//

//	Whether or not we need normal, detail or envmapmask uv modifications.
//  STATIC: "DETAILTEXTURE_UV"			"0..1"
//  STATIC: "ENVMAPMASK_UV"				"0..1"
//	STATIC:	"PARALLAXMAPPING"			"0..1"

// We cannot use Vertex colors with seamless coordinates because of the maximum amounts of vertex shader output registers.
// FIXME : I think this skip doesn't work, I had to add !VERTEX_RGBA to everything so it wouldn't error out on these combinations.
// SKIP: ($VERTEX_RGBA == 1 && (SEAMLESS_BASE || DETAILTEXTURE_UV == 2 || NORMALTEXTURE_UV == 2 || ENVMAPMASK_UV == 2))

// We include both common_vs_fxc.h and common_fxc.h ( through vs_fxc.h )
// This is done to get definitions etc for vertex shaders 
// #include "common_vs_fxc.h"

// Include for lux shaders
#include "lux_common_vs_fxc.h"

const float4 cBaseTexCoordTransform[2]			:	register(	SHADER_SPECIFIC_CONST_13	);	// 13 & 14
const float4 cNormalTexCoordTransform[2]		:	register(	SHADER_SPECIFIC_CONST_15	);	// 15 & 16

#if DETAILTEXTURE_UV
const float4 cDetailTexCoordTransform[2]		:	register(	SHADER_SPECIFIC_CONST_17	);	// 17 & 18
#endif

// Only used for Override.
#if ENVMAPMASK_UV
const float4 cEnvMapMaskTexCoordTransform[2]	:	register(	SHADER_SPECIFIC_CONST_19	);	// 19 & 20
#endif





//-----------------------------------------------------------------------------
// Input vertex format
//-----------------------------------------------------------------------------
struct VS_INPUT
{
    // This is all of the stuff that we ever use
    float4 vPos                     : POSITION;
	float4 vBoneWeights             : BLENDWEIGHT;	//	Despite no bones,
	float4 vBoneIndices             : BLENDINDICES; //	we use these in SkinPositionAndNormal()
    float4 vNormal                  : NORMAL;
    float2 vTexCoord0               : TEXCOORD0;
    float4 vLightmapTexCoord        : TEXCOORD1;
    float4 vLightmapTexCoordOffset  : TEXCOORD2;
	float4 vColor                   : COLOR0;
//	float3 vSpecular				: COLOR1;
};

struct VS_OUTPUT
{
    // Stuff that isn't seen by the pixel shader
	// This is used by the GPU to determine what's actually rendered on-screen ( The actual screenspace position of our triangles )
    float4 ProjPosSetup				:	POSITION;
//  float  Fog						:	FOG;
    // Stuff that is seen by the pixel shader
    float4	BaseDetailTexCoord		:	TEXCOORD0;
	float4	NormalEMMTexCoord		:	TEXCOORD1;
	float3	WorldNormal				:	TEXCOORD2;
	float3	WorldPos				:	TEXCOORD3;
	float3	ProjPos					:	TEXCOORD4;
	float4	LightmapTexCoord1And2	:	TEXCOORD5;
	float4	LightmapTexCoord3		:	TEXCOORD6;
//	float4	EMPTY					:	TEXCOORD7;
	// Can't add any more than this. Need to do exclusion
};

//-----------------------------------------------------------------------------
// Main shader entry point
//-----------------------------------------------------------------------------
VS_OUTPUT main( const VS_INPUT v )
{
	VS_OUTPUT o = ( VS_OUTPUT )0;
	
	float3 vNormal;
	DecompressVertex_Normal(v.vNormal, vNormal);
	
	// We mainly use SkinPositionAndNormal because we want the normal ( and pos )
	float3 WorldNormal, WorldPos;
	SkinPositionAndNormal(false, v.vPos, vNormal, v.vBoneWeights, v.vBoneIndices, WorldPos, WorldNormal);
	
	// Transform into projection space
	float4 vProjPos = mul(float4(WorldPos, 1), cViewProj);
	o.ProjPosSetup = vProjPos;
	vProjPos.z = dot(float4(WorldPos, 1), cViewProjZ);
	
	o.ProjPos.xyz = vProjPos.xyz;
//	o.Fog = CalcFog(WorldPos, vProjPos.xyz, g_FogType);
	
	// Needed for water fog alpha and diffuse lighting 
	o.WorldPos.xyz = WorldPos;
	o.WorldNormal.xyz = normalize(WorldNormal);
	
	o.LightmapTexCoord3.z = v.vTexCoord0.x * cBaseTexCoordTransform[0].x + cBaseTexCoordTransform[0].w;
	o.LightmapTexCoord3.w = v.vTexCoord0.y * cBaseTexCoordTransform[1].y + cBaseTexCoordTransform[1].w;
	o.LightmapTexCoord1And2.xy = v.vLightmapTexCoord + v.vLightmapTexCoordOffset;
	
	float2 LightmapTexCoord2 = o.LightmapTexCoord1And2.xy + v.vLightmapTexCoordOffset;
	float2 LightmapTexCoord3 = LightmapTexCoord2 + v.vLightmapTexCoordOffset;
	
	// Reversed component order
	o.LightmapTexCoord1And2.w = LightmapTexCoord2.x;
	o.LightmapTexCoord1And2.z = LightmapTexCoord2.y;
	o.LightmapTexCoord3.xy = LightmapTexCoord3;
	
	o.BaseDetailTexCoord.x = v.vTexCoord0.x * cBaseTexCoordTransform[0].x + cBaseTexCoordTransform[0].w;
	o.BaseDetailTexCoord.y = v.vTexCoord0.y * cBaseTexCoordTransform[1].y + cBaseTexCoordTransform[1].w;
	
	// DetailTexture Coordinate Transform
	#if DETAILTEXTURE_UV
		o.BaseDetailTexCoord.z = v.vTexCoord0.x * cDetailTexCoordTransform[0].x + cDetailTexCoordTransform[0].w;
		o.BaseDetailTexCoord.w = v.vTexCoord0.y * cDetailTexCoordTransform[1].y + cDetailTexCoordTransform[1].w;
	#endif

	// NormalTexture Coordinate Transform
		o.NormalEMMTexCoord.x = v.vTexCoord0.x * cNormalTexCoordTransform[0].x + cNormalTexCoordTransform[0].w;
		o.NormalEMMTexCoord.y = v.vTexCoord0.y * cNormalTexCoordTransform[1].y + cNormalTexCoordTransform[1].w;

	// EnvMapMask Coordinate Transform
	#if ENVMAPMASK_UV
			o.NormalEMMTexCoord.z = v.vTexCoord0.x * cEnvMapMaskTexCoordTransform[0].x + cEnvMapMaskTexCoordTransform[0].w;
			o.NormalEMMTexCoord.w = v.vTexCoord0.y * cEnvMapMaskTexCoordTransform[1].y + cEnvMapMaskTexCoordTransform[1].w;
	#endif

    return o;
}