//==================================================================================================
//
// Physically Based Rendering pixel shader for player models
// ripped out some stuff to make this work from the standard pbr shader, brushes arent supported or the flashlight
//==================================================================================================
// c0    g_HSV
// c1    g_DiffuseModulation
// c2    
// c3    g_EmissionScale  
// c4    cAmbientCube[6]
// c5    cAmbientCube[6]
// c6    cAmbientCube[6]
// c7    cAmbientCube[6]
// c8    cAmbientCube[6]
// c9    cAmbientCube[6]
// c10    
// c11    g_EyePos
// c12    g_FogParams
// c13    g_cColor1
// c14    g_cColor2
// c15    g_cColor3
// c16                            free
// c17                            free
// c18                            free
// c19                            free
// c20    cLightInfo[3]
// c21    cLightInfo[3]
// c22    cLightInfo[3]
// c23    cLightInfo[3]
// c24    cLightInfo[3]
// c25    cLightInfo[3]
// c26	  g_MraoScale
// c27    "//actually using this often blows constant limits, since literals have to get stuffed somewhere..."
// c28    
// c29    g_LinearFogColor
// c30    cLightScale
// c31    


// STATIC: "EMISSIVE"                   "0..1"
// STATIC: "HSV"                        "0..1"
// STATIC: "HSV_BLEND"                  "0..1"
//only to work with the pbr header
// STATIC: "FLASHLIGHT"					"0..1"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "NUM_LIGHTS"                "0..4"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"

// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)

// SKIP: !$HSV && $HSV_BLEND

#include "common_ps_fxc.h"
//#include "common_flashlight_fxc.h"
#include "common_lightmappedgeneric_fxc.h"
#include "shader_constant_register_map.h"
#include "pbr_common_ps2_3_x.h"

const float4 g_HSV                              : register(c0);
const float4 g_DiffuseModulation                : register(c1);
//const float4 g_ShadowTweaks                     : register(c2);
const float4 g_EmissionScale                    : register(c3);
const float3 cAmbientCube[6]                    : register(c4);
const float4 g_EyePos                           : register(c11); //(PSREG_EYEPOS_SPEC_EXPONENT);
const float4 g_FogParams                        : register(c12);
const float4 g_cColor1							: register(c13);//(PSREG_FLASHLIGHT_ATTENUATION);
const float4 g_cColor2							: register(c14);//(PSREG_FLASHLIGHT_POSITION_RIM_BOOST);
const float4 g_cColor3							: register(c15);//(PSREG_FLASHLIGHT_TO_WORLD_TEXTURE);

PixelShaderLightInfo cLightInfo[3]              : register(PSREG_LIGHT_INFO_ARRAY);         // 2 registers each - 6 registers total (4th light spread across w's)
const float4 g_MraoScale                        : register(c26);

#define lightMapScale g_HSV.w

sampler BaseTextureSampler          : register(s0);     // Base map, selfillum in alpha
sampler NormalTextureSampler        : register(s1);     // Normal map
sampler EnvmapSampler               : register(s2);     // Cubemap
//sampler ShadowDepthSampler          : register(s4);     // Flashlight shadow depth map sampler
//sampler RandRotSampler              : register(s5);     // RandomRotation sampler
//sampler FlashlightSampler           : register(s6);     // Flashlight cookie 
sampler LightmapSampler             : register(s7);     // Lightmap
sampler MRAOTextureSampler          : register(s10);    // MRAO texture
#if EMISSIVE
sampler EmissionTextureSampler      : register(s11);    // Emission texture
#endif

sampler PlayerColorSampler			: register(s15);



#define ENVMAPLOD (g_EyePos.a)

struct PS_INPUT
{
    float2 baseTexCoord             : TEXCOORD0;
    float4 lightAtten               : TEXCOORD1;
    float3 worldNormal              : TEXCOORD2;
    float3 worldTangent             : TEXCOORD3;
    float3 worldPos                 : TEXCOORD4;
    float3 projPos                  : TEXCOORD5;
    float4 lightmapTexCoord1And2    : TEXCOORD6;
    float4 lightmapTexCoord3        : TEXCOORD7;
};

// Entry point
float4 main(PS_INPUT i) : COLOR
{
    float2 correctedTexCoord = i.baseTexCoord;
    float4 albedo = tex2D(BaseTextureSampler, correctedTexCoord);
    albedo.xyz *= g_DiffuseModulation;
	
	float4 mask = tex2D(PlayerColorSampler, i.baseTexCoord);
	if (mask.r > 0)
	{
		albedo.xyz *= g_cColor1.rgb;// * mask.r;
	};
	if (mask.g > 0)
	{
		albedo.xyz *= g_cColor2.rgb;//* mask.g;
	};	
	if (mask.b > 0)
	{
		albedo.xyz *= g_cColor3.rgb;// * mask.b;
	};
	
    float4 mrao = tex2D(MRAOTextureSampler, i.baseTexCoord) * float4(g_MraoScale.xyz, 1);

    float metalness = mrao.x, roughness = mrao.y, ambientOcclusion = mrao.z;

#if EMISSIVE
    float3 emission = tex2D(EmissionTextureSampler, correctedTexCoord).xyz * g_EmissionScale.xyz;
#if HSV
    float3 emissionHSV = rgb2hsv(emission);
    emissionHSV.x = fmod(emissionHSV.x + g_HSV.x, 1.0);
    emissionHSV.yz = clamp(emissionHSV.yz * g_HSV.yz, 0.0, 1.0);
#if !HSV_BLEND
    emission.xyz = hsv2rgb(emissionHSV);
#else
    emission.xyz = lerp(emission.xyz, hsv2rgb(emissionHSV), mrao.w);
#endif
#endif
#endif

#if HSV
    float3 albedoHSV = rgb2hsv(albedo.rgb);
    albedoHSV.x = fmod(albedoHSV.x + g_HSV.x, 1.0);
    albedoHSV.yz = clamp(albedoHSV.yz * g_HSV.yz, 0.0, 1.0);
#if !HSV_BLEND
    albedo.xyz = hsv2rgb(albedoHSV);
#else
    albedo.xyz = lerp(albedo.xyz, hsv2rgb(albedoHSV), mrao.w);
#endif
#endif

    float3x3 normalBasis = float3x3(i.worldTangent, cross(i.worldNormal, i.worldTangent), i.worldNormal);
    float3 textureNormal = normalize((tex2D( NormalTextureSampler, correctedTexCoord).xyz - float3(0.5, 0.5, 0.5)) * 2);
    float3 normal = normalize(mul(textureNormal, normalBasis)); // World Normal
	
    float3 outgoingLightDirection = normalize(g_EyePos.rgb - i.worldPos); // Lo
    float lightDirectionAngle = max(0, dot(normal, outgoingLightDirection)); // cosLo

    float3 specularReflectionVector = 2.0 * lightDirectionAngle * normal - outgoingLightDirection; // Lr

    float3 dielectricCoefficient = 0.04; // F0 dielectric
    float3 fresnelReflectance = lerp(dielectricCoefficient, albedo.rgb, metalness); // F0

    // Prepare ambient and direct
    float3 ambientLighting = 0.0;
    float3 directLighting = 0.0;

    float4 modul = g_DiffuseModulation;
#if HSV
    float3 modulHSV = rgb2hsv(modul.rgb);
    modulHSV.x = fmod(modulHSV.x + g_HSV.x, 1.0);
    modulHSV.yz = clamp(modulHSV.yz * g_HSV.yz, 0.0, 1.0);
#if !HSV_BLEND
    modul.xyz = hsv2rgb(modulHSV);
#else
    modul.xyz = lerp(modul.xyz, hsv2rgb(modulHSV), mrao.w);
#endif
#endif

    // Start ambient
    float3 diffuseIrradiance = ambientLookup(normal, cAmbientCube, textureNormal, i.lightmapTexCoord1And2, i.lightmapTexCoord3, LightmapSampler, modul);
    float3 ambientLightingFresnelTerm = fresnelSchlick(fresnelReflectance, lightDirectionAngle); // F

    float3 diffuseContributionFactor = lerp(1 - ambientLightingFresnelTerm, 0, metalness); ; // kd
    float3 diffuseIBL = diffuseContributionFactor * albedo.rgb * diffuseIrradiance;

    float4 specularUV = float4(specularReflectionVector, roughness * ENVMAPLOD);
    float3 lookupHigh = ENV_MAP_SCALE * texCUBE(EnvmapSampler, specularUV.xyz).xyz;

    float3 lookupLow = PixelShaderAmbientLight(specularReflectionVector, cAmbientCube);
    float3 specularIrradiance = lerp(lookupHigh, lookupLow, roughness * roughness);
    float3 specularIBL = specularIrradiance * EnvBRDFApprox(fresnelReflectance, roughness, lightDirectionAngle);

    ambientLighting = (diffuseIBL + specularIBL) * ambientOcclusion;
    // End ambient

    // Start direct
    for (int n = 0; n < NUM_LIGHTS; ++n)
    {
        float3 LightIn = normalize(PixelShaderGetLightVector(i.worldPos, cLightInfo, n));
        float3 LightColor = PixelShaderGetLightColor(cLightInfo, n) * GetAttenForLight(i.lightAtten, n); // Li

        directLighting += calculateLight(LightIn, LightColor, outgoingLightDirection,
            normal, fresnelReflectance, roughness, metalness, lightDirectionAngle, albedo.rgb);
    }
    // End direct
    
    float fogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, i.worldPos.xyz, i.projPos.z);


#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    float alpha = fogFactor;
#else
    float alpha = albedo.a;
#endif // WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

    float3 combinedLighting = directLighting + ambientLighting;

#if EMISSIVE
    combinedLighting += emission;
#endif

    alpha *= g_DiffuseModulation.a;
    return FinalOutput(float4(combinedLighting, alpha), fogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, i.projPos.z);
}
