// shadertype=hlsl
//========= ShiroDkxtro2's --ACROHS Ultimate Shaders Project-- ============//
//
//	Initial D.	:	21.03.2023 DMY
//	Last Change :	02.04.2023 DMY
//
//	Purpose of this File :	PBR Shader ps30, to be used on Models
//
//===========================================================================//

// STATIC:	"FLASHLIGHT"                "0..0"
// STATIC:	"SPECIALPROPERTIES"			"0..0"
// STATIC:	"REFRACTION"				"0..1"
// STATIC:	"BRUSH"						"0..1"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"
// DYNAMIC: "FLASHLIGHTSHADOWS"         "0..1"
// DYNAMIC: "NUM_LIGHTS"                "0..4"
// DYNAMIC: "LIGHTMAPPED_MODEL"			"0..0"

// Set to 0 if you are NOT on ACROHS
// DYNAMIC: "CASCADED_SHADOW"			"0..0"

// SKIP: $CASCADED_SHADOW && $FLASHLIGHT
// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)
// We don't care about flashlight depth unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTSHADOWS == 1 )

// SKIP: $LIGHTMAPPED_MODEL && $SPECIALPROPERTIES

// This is used to disable features automatically.
#include "ACROHS_Defines.h"

// This IS a Shader used on BRUSHES and MODELSFi
#if !BRUSH
#define MODEL
#endif

// This Shaders USES Normalmaps
#define NORMALTEXTURE

// This should enable Envmapping behaviour.
#define ENVMAPMODE 1

//	This has to be included first. It includes pragmas, #define's, and the register map.
#include "lux_common_ps_fxc.h"
// SelfIllum Data
#include "lux_common_selfillum.h"
// EnvMapping Data
#include "lux_common_envmap.h"
// common flashlight function.
#include "lux_common_flashlight.h"

#if BRUSH
// Lightmapping related functions
#include "lux_common_lightmapped.h"
#endif

#include "pbr_combined_functions.h"

/*
float3 Refract(float3 I, float3 N, float eta)
{
    float cosI = dot(-I, N);
    float sinT2 = eta * eta * (1.0 - cosI * cosI);
    if (sinT2 > 1.0) return float3(0.0, 0.0, 0.0); // Total internal reflection
    float cosT = sqrt(1.0 - sinT2);
    return eta * I + (eta * cosI - cosT) * N;
}
*/

float2 RefractUV(float2 PixelPosition, float3 f3ViewVector, float3 f3NormalTexture, float f1IOR)
{
    // Compute the incident direction
    float3 f3Incident = f3ViewVector;
    
    // Compute the refracted direction using Snell's law
    float f1CosI = dot(f3NormalTexture, f3Incident);
    float f1SinI = sqrt(max(0.0, 1.0 - f1CosI * f1CosI));
    float f1SinT = f1SinI / f1IOR;
    float f1CosT = sqrt(max(0.0, 1.0 - f1SinT * f1SinT));
    float3 f3Refracted = f1IOR * f3Incident + (f1IOR * f1CosI - f1CosT) * f3NormalTexture;
    
    // Compute the refracted position in world space
    float3 f3RefractedPosition = f3ViewVector + f3Refracted;
    
    // Compute the texture coordinates for the refracted position
    float2 f2RefractedUV = f3RefractedPosition.xy * (1.0 / f1IOR); // divided... .xy / f3RefractedPosition.z
    
    return f2RefractedUV;
}

sampler Sampler_1	: register(s1);

// const float4 g_ParallaxControls : register(c50);
#define f1ScreenWidth			(g_ParallaxControls.x)
#define f1ScreenHeight			(g_ParallaxControls.y)

struct PS_INPUT
{
//	float4	position : SV_POSITION;
	float4	ScreenPosition			: SV_POSITION;
    float4	BaseTexCoord			:	TEXCOORD0;
	float3	WorldNormal				:	TEXCOORD2;
	float3	WorldPos				:	TEXCOORD3;
	float3	ProjPos					:	TEXCOORD4;
	float4	LightmapTexCoord1And2	:	TEXCOORD5; // Explanation : .xy = bHasLightMapUVs ? LightMapUVs : BaseTextureUVs; We check this on the Vertexshader!
#if BRUSH
	float4	LightmapTexCoord3		:	TEXCOORD6;
#else
	float4	LightAtten				:	TEXCOORD6;
#endif
};

// Entry point
float4 main(PS_INPUT i) : COLOR
{
	//	Getting our PS_INPUT... TODO/FIXME: Does this require more memory?
	//===========================================================================//
	// Integer Constants are for use with loops only...
//	int iDebug			 = trunc(g_VariousControls1.x);
	float LOD			 = g_VariousControls1.y;
	float f1IOR			 = g_VariousControls1.x;

	// int g_Debug = trunc(DEBUG.x);

	float2 f2BaseTextureUV = i.BaseTexCoord.xy;
	float2 f2NormalUV = f2BaseTextureUV;

	// .xyz's in case we need to pack something later
	float3 f3WorldPosition		= i.WorldPos.xyz;
	float3 f3ProjectPosition	= i.ProjPos.xyz;
	float2 f2LightmapUV			= i.LightmapTexCoord1And2.xy;

	// ShiroDkxtro2 :	We do this like the PBR Shader.
	//					Tottery says this causes issues on smoothed models.
	//					However, it means we can receive more things from the Vertex Shader
	//					And I have not noticed any of such Issues.
	float4 f4ScreenPos  = i.ScreenPosition;
	float3 f3FaceNormal = normalize(i.WorldNormal);
	float3 f3WorldNormal = f3FaceNormal;
    float3 f3SurfaceTangent;
    float3 f3SurfaceBase; 
    float f1FlipSign;
    float3x3 f3x3NormalBasis = Compute_Tangent_Frame(f3FaceNormal, f3WorldPosition, f2NormalUV.xy , f3SurfaceTangent, f3SurfaceBase, f1FlipSign);
	float3	f3ViewVector = normalize(g_EyePos.xyz - f3WorldPosition); // Lo

	//===========================================================================//
	//	Getting the current Pixels Color from the Samplers
	//===========================================================================//

	float4	f4BaseTexture		=	tex2D(Sampler_1, f2BaseTextureUV.xy);	
	float4	f4NormalTexture		=	tex2D(Sampler_NormalTexture, f2NormalUV.xy);	
	float4	f4MRAO				=	tex2D(Sampler_MRAO, f2BaseTextureUV.xy);
	f4BaseTexture.xyz		   *=	f3BaseTextureTint;

	// Set up MRAO terms :
			f4MRAO.x			=	clamp(f4MRAO.x + f1MetallicBias	   ,0.0f ,1.0f); // evil leveling
			f4MRAO.y			=	clamp(f4MRAO.y + f1RoughnessBias   ,0.0f ,1.0f); // evil leveling
			f4MRAO.z			=	clamp(f4MRAO.z + f1AOBias		   ,0.0f ,1.0f); // evil leveling
	float	f1Metalness			=	f4MRAO.x;
	float	f1Roughness			=	f4MRAO.y;
	float	f1AmbientOcclusion	=	f4MRAO.z;
	float3	f3Specular			=	lerp(f1DiElectricCoefficient.xxx, f4BaseTexture.rgb, f1Metalness); // ( DiElectricCoefficient  default is 0.025 now )
	float3	f3Albedo			=	f4BaseTexture.xyz * ( 1.0f - f1Metalness );
//			f3Albedo		   *=	PI; // 3.141593. Rounded up
//	Wetness And Porisity modifaction for input textures.
//	Adapted from Uncharted TechArt pdf
//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
//	VectorLayer is our own implementation!
#if SPECIALPROPERTIES

// FIXME:	f4NormalTexture.xy is probably calculated incorrectly.
//			In the pdf they do float2 but this kind of implies they only want to modify two components... doesn't it?

float4	f4PropertiesTexture		=	tex2D(Sampler_Properties , f2BaseTextureUV.xy);
float	f1Wetness				=	f4PropertiesTexture.x;
float	f1Porosity				=	f4PropertiesTexture.y;
float	f1VectorBlendMask		=	f4PropertiesTexture.z;
float	f1VectorLayerRoughness	=	f4PropertiesTexture.w;
float4	f4VectorLayerTexture	=	tex2D(Sampler_VectorLayer , f2BaseTextureUV.xy); // Uses the same sampler as the detailtexture
float3	f3VectorLayerTexture	=	f4VectorLayerTexture.xyz;
float	f1VectorLayerAO			=	f4VectorLayerTexture.w;
float	f1VectorBlend			=	0.0f;
if(bVectorBlend)
{
	// We clamp the dot at 0. If the Normal and Desired is -1 they will return 1.0f. Otherwise only positive values will persist.
	f1VectorBlend				=	max(0.0f, dot(f3DesiredVector, f3WorldNormal)); // If they are the same. 1.0f, slowly progressing there...
	f1VectorBlend				=	smoothstep(f1VectorLayerFactor, 1.0f, f1VectorBlend); // Only 0.3 difference... Otherwise you will have a smooth falloff... Which we don't want.
	f1VectorBlend				*=	f1VectorBlendMask; // f1VectorLayerFactor = artist input

	f3Albedo					=	lerp(f3Albedo			,f3VectorLayerTexture		, f1VectorBlend);
	f1Roughness					=	lerp(f1Roughness		,f1VectorLayerRoughness		, f1VectorBlend);
	f3Specular					=	lerp(f3Specular			,float3(0.0f, 0.0f, 0.0f)	, f1VectorBlend);
	f1AmbientOcclusion			=	lerp(f1AmbientOcclusion	,f1VectorLayerAO			, f1VectorBlend);
}

if(bWetnessPorosity)
{
		f1Wetness				=	clamp(f1Wetness + f1WetnessBias, 0.0f , 1.0f); // evil leveling
float3	f3SaturatedAlbedo		=	f3Albedo * f3Albedo; // Square
		f3Albedo				=	lerp(f3Albedo			, f3SaturatedAlbedo	, ClampRange(f1Wetness, 0.00f, 0.35f) * f1Porosity);
		f1Roughness				=	lerp(f1Roughness		, 0.10f				, ClampRange(f1Wetness, 0.20f, 1.00f));
		f3Specular				=	lerp(f3Specular			, 0.25f				, ClampRange(f1Wetness, 0.25f, 0.50f));
		f1AmbientOcclusion		=	lerp(f1AmbientOcclusion	, 1.00f				, ClampRange(f1Wetness, 0.45f, 0.95f));										
		f4NormalTexture.xy		=	lerp(f4NormalTexture.xy	, float2(0.5f, 0.5f), ClampRange(f1Wetness, 0.45f, 0.95f));
		f3WorldNormal			=	lerp(f3WorldNormal		, float3(0, 0, 1.0f), ClampRange(f1Wetness, 0.98f, 1.00f));
		f3WorldNormal			=	normalize(f3WorldNormal);
}
#endif

	//==============================================================================================================//
	// We want to do the below as late as possible so we can modify everything with wetness/porosity first above.
	//==============================================================================================================//

	// Important to use WorldNormal. We want actual direction of the surface, and not fake one.
		float	f1NdotV				=	max( dot( f3WorldNormal, f3ViewVector ), 0.0f ); // cosLo

	//	AO Fresnel. ( AO should not appear when viewing from the front. )
	//	AO happens when a pixel is occluded by nearby geometry. This is not the case when you look at it from the front.
	//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
			f1AmbientOcclusion	=	lerp(1.0f, f1AmbientOcclusion, f1NdotV);
	float3	f3NormalTexture		=	normalize((f4NormalTexture.xyz * 2.0f - 1.0f ) * 2.0f); // Perturbed Normals
	// Merge Facenormal and Normalmap together for reflection vector etc.
			f3FaceNormal		=	normalize(mul(f3NormalTexture, f3x3NormalBasis));

    // Prepare ambient and direct
    float3 f3AmbientLighting = 0.0f;
    float3 f3DirectLighting = 0.0f;

#if !FLASHLIGHT

#if !BRUSH
	float	f1aLightAttenuations[4] = {0.0, 0.0, 0.0, 0.0};
			f1aLightAttenuations[0] = i.LightAtten.x;
			f1aLightAttenuations[1] = i.LightAtten.y;
			f1aLightAttenuations[2] = i.LightAtten.z;
			f1aLightAttenuations[3] = i.LightAtten.w;

//	[unroll] // Tell the compiler to forcibly unroll this.
    for (int i = 0; i < NUM_LIGHTS; i++)
    {
		float3	f3LightIn = float3(0,0,0);
		float3	f3LightColor = float3(0,0,0);
		if ( i == 3 ) // I wonder if the compiler can unroll this... mhm
		{
			// Unpack light 3 from w components...
			f3LightColor = float3( cLightInfo[0].color.w, cLightInfo[0].pos.w, cLightInfo[1].color.w );
			f3LightIn = normalize( float3( cLightInfo[1].pos.w, cLightInfo[2].color.w, cLightInfo[2].pos.w ) - f3WorldPosition);
		}
		else
		{
			f3LightColor = cLightInfo[i].color.rgb;
			f3LightIn = normalize( cLightInfo[i].pos - f3WorldPosition);
		}

		f3LightColor =	PBR_ComputeLight(f3LightIn, f3WorldPosition, f3FaceNormal, f3LightColor);		
		f3LightColor = UnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3LightIn, f3LightColor) * f1aLightAttenuations[i];

		// Apply Shadows and Microshadows to the desired amount. 
			f3DirectLighting += f3LightColor * lerp(1.0f, ApplyMicroShadows(f1AmbientOcclusion, f3FaceNormal, f3LightIn), g_VariousControls1.z) ;	 // f3LightColor;
    }
#else
	// Use FaceNormal and this will doom the resulting lightmap.
	

	f3DirectLighting = LUX_BumpedLightmap(f3NormalTexture, i.LightmapTexCoord1And2, i.LightmapTexCoord3);

	f3DirectLighting = StaticUnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3DirectLighting);
#endif

	//	We do cubemap ambient cubes because there is no ambient cubes for static props. That way we could also use this on brushes and make things look somewhat consistent.
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, Sampler_EnvironmentMap);

	// A better reflection vector...
	float3 f3ReflectionVector = 2.0 * f1NdotV * f3FaceNormal - f3ViewVector;

	// Lookup the Texture using f3ReflectionVector as the VectorUV for the Cubemap. ( which pixel it points at)
    float4 f4SpecularUV = float4(f3ReflectionVector, f1Roughness * LOD); // ENVMAPLOD
	float3 f3SpecularLookUp = ENV_MAP_SCALE * texCUBElod(Sampler_EnvironmentMap, f4SpecularUV).xyz;
	float3 f3LookupLow = AmbientLight(f4SpecularUV.xyz, cAmbientCube);

	// REFRACTION CODE

	// Refraction Direction

	// Air IOR = 1.0
	// Glass IOR ~1.5 ( impure one is ~1.9 )
	// Water IOR 1.33

//	float3 Reflection = getReflection(f3WorldNormal, f3ViewVector);
//	float3 Refraction = getRefraction(f3WorldNormal, f3ViewVector, 1.0f, 1.52f)


	// 

	f3SpecularLookUp *= f3EnvMapTint;
	float3 f3LookupHighSaturated = f3SpecularLookUp * f3SpecularLookUp;
	f3SpecularLookUp = lerp( f3SpecularLookUp, f3LookupHighSaturated, f1EnvMapContrast );

	// If you are curious this has to do with perception.
	float3 f3DesaturatedCubemap = dot( f3SpecularLookUp, f3LumCoefficients );
	f3SpecularLookUp = lerp( f3DesaturatedCubemap, f3SpecularLookUp, f3EnvMapSaturation );

    float3 f3SpecularIrradiance = lerp(f3SpecularLookUp, f3LookupLow, f1Roughness * f1Roughness);
    float3 f3SpecularIBL = f3SpecularIrradiance * EnvBRDFApprox(f3Specular, f1Roughness, f1NdotV);

//	f3SpecularIBL = UnrealDiffuseIBL(f3SpecularIBL, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, float3(1,1,1), float3(1,1,1));
//	StaticUnrealDiffuseIBL(f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3SpecularIBL);

    // End ambient

	// REFRACTION



    // Start direct
	// Lightmapped model should only have NUM_LIGHTS for named lights!
	// That way you can have bumped lighting from non static lightsources!
	// Information from Static Light sources is already baked into the lightmap.
	// If you want the "funny phong reflections" you must use bumped lightmaps, and that requires a heavily custom compiler.

// Lightmap_Sampler == Properties Sampler
#if LIGHTMAPPED_MODEL
// If the model is lightmapped, we draw lighting from the texture.
	float3	f3DiffuseIBL = StaticUnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f1NdotV, f3FaceNormal, tex2D(Sampler_LightMap, f2LightmapUV).xyz * 2.0f);
	f3DirectLighting = f3DiffuseIBL;
	f3SpecularIBL = lerp(f3SpecularIBL, f3SpecularIBL * saturate(f3DiffuseIBL), f1EnvMapLightScale);
	f3AmbientLighting = f3SpecularIBL * f1AmbientOcclusion;
#else
// $EnvMapLightScale
	f3SpecularIBL = lerp(f3SpecularIBL, f3SpecularIBL * saturate(f3DirectLighting), f1EnvMapLightScale);
	f3AmbientLighting = f3SpecularIBL * f1AmbientOcclusion;
#endif

	// Thank you Blizzard / Activision
	// Specular Occlusion.
	// Occludes at grazing angles, assumes isotropic occlusion.
	// This.. Doesn't really change anything...?
	/*
	static const float f1SpecularPow = 8.0f;
	float	f1SpecularOcclusion	= saturate(-0.3 + f1NdotV * f1NdotV);
			f1SpecularOcclusion	= lerp(pow(f1AmbientOcclusion, f1SpecularPow), 1.0f, f1SpecularOcclusion);
	f3SpecularIBL *= f1SpecularOcclusion;
	*/

#else  // End direct

// TODO: Pack this into a neat little function inside our Header.
	float4 f4FlashlightSpacePosition = mul(float4(f3WorldPosition, 1.0), g_FlashlightWorldToTexture);
	clip(f4FlashlightSpacePosition.w);

	float3 f3ProjCoords = f4FlashlightSpacePosition.xyz / f4FlashlightSpacePosition.w;

	float3 f3FlashlightColor = tex2D(Sampler_FlashlightCookie, f3ProjCoords.xy).xyz;

	// Removed some ifdef for Shadermodels here.
	f3FlashlightColor *= cFlashlightColor.xyz;

	float3	f3Delta = g_FlashlightPos.xyz - f3WorldPosition;
	float3	f3L = normalize(f3Delta);
	float	f1DistSquared = dot(f3Delta, f3Delta);
	float	f1Dist = sqrt(f1DistSquared);

	float	f1FarZ = g_FlashlightAttenuationFactors.w;
	float	f1EndFalloffFactor = RemapValClamped(f1Dist, f1FarZ, 0.6f * f1FarZ, 0.0f, 1.0f);

	// Attenuation for light and to fade out shadow over distance
	float	f1Atten = saturate(dot(g_FlashlightAttenuationFactors.xyz, float3(1.0f, 1.0f / f1Dist, 1.0f / f1DistSquared)));

/*
#if FLASHLIGHTSHADOWS
		// TODO: Figure out if this was set to 2048 because of forced Shadow Resolution or because its good values...
		float f1Shadow = LUX_DoShadowNvidiaPCF5x5Gaussian(f3ProjCoords, float2(1.0 / 2048.0, 1.0 / 2048.0));
		float f1Attenuated = lerp(saturate(f1Shadow), 1.0f, g_ShadowTweaks.y);	// Blend between fully attenuated and not attenuated
		
		f1Shadow = saturate(lerp(f1Attenuated, f1Shadow, f1Atten));	// Blend between shadow and above, according to light attenuation
		f3FlashlightColor *= f1Shadow;									// Shadow term
#endif
*/

	float3 f3DiffuseLighting = f1Atten;
	f3DiffuseLighting *= saturate(dot(f3L.xyz, f3FaceNormal) + f1FlashlightNoLambertValue); // NoLambertValue is either 0 or 2
	
	f3DiffuseLighting *= f3FlashlightColor;
	f3DiffuseLighting *= f1EndFalloffFactor;

	f3DirectLighting += UnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3L, f3DiffuseLighting);

#endif // !FLASHLIGHT

    float f1FogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, f3WorldPosition, f3ProjectPosition.z);

#if !FLASHLIGHT
#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    float f1Alpha = f1FogFactor;
#else
    float f1Alpha = f4BaseTexture.a;
#endif // WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
#else
    float f1Alpha = 0.0f;
#endif // !FLASHLIGHT

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

	// Combine the results
//	float4 f4Result = float4(f3DirectLighting + f3AmbientLighting ,f1Alpha);

//	float2	PixelPosition	= f3ProjectPosition.xy / f3ProjectPosition.z;
//	float2	ScreenSize		= float2(f1ScreenWidth, f1ScreenHeight);
//	float2	PixelPosition	= f4ScreenPos.xy / ScreenSize; // (1.0f + (f3ProjectPosition.xy / f3ProjectPosition.z)) * 0.5f;
//	PixelPosition.y = 1.0f - PixelPosition.y; // Flip so its aligned properly again...

//	f4Framebuffer = float4(), 0, 0);
// f3DirectLighting

// HERE WE GO, RACING CONDITIONS
// NEEEEAUUUWWWWW
// Sampler_BaseTexture = FrameBuffer Sampler in this case
// float4 f4Framebuffer	= tex2D(Sampler_BaseTexture, PixelPosition); // f4BaseTexture.w

/*
None of this works at all. And I just don't understand this enough to give a damn
No refraction for you. RIP
I think the issue is because we are supposed to use ProjPos, however, IT DOESN'T WORK
because for some stupid reason its all out of range
whatever I try to do with it, it ends up fucked
and its not even in real viewspace
its not even a fucking 0-1 range
and I ahve no fucking idea whats the .z in it supposed to do
if you look up code online they will even use the fucking w component????
what the fuck is the w component??? I DON'T KNOW???? I DON'T EVEN KNOW WHAT IS THE Z COMPONENT NO ONE EXPLAINED THIS TO ME
#if REFRACTION

float3 refractWS = refract(f3ViewVector, f3WorldNormal, f1IOR);

float rayLengthSolid = 1.0f;
float rayLengthShell = thickness / max(f4Framebuffer.w * f1NdotV, 0.5f);
float rayLength = lerp(rayLengthSolid, rayLengthShell, 0.0f);

float3 refractVectorWS = refractWS * rayLength;
float3 refractionLight 

#endif
*/
float4 f4Result = float4(f3AmbientLighting + (f3DirectLighting / max(f4BaseTexture.w, 0.01f)),f1Alpha);

//	f4Result = float4((f4BaseTexture.xyz * f4BaseTexture.w) + (f4Framebuffer.xyz * (1.0f - f4BaseTexture.w)), f4Framebuffer.w);
	return FinalOutput(f4Result, f1FogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, f3ProjectPosition.z);
}

