// shadertype=hlsl
//========= ShiroDkxtro2's --ACROHS Ultimate Shaders Project-- ============//
//
//	Initial D.	:	21.03.2023 DMY
//	Last Change :	02.04.2023 DMY
//
//	Purpose of this File :	PBR Shader ps30, to be used on Models
//
//===========================================================================//

// STATIC:	"FLASHLIGHT"                "0..1"
// STATIC:	"EMISSION"	                "0..1"
// STATIC:	"SPECIALPROPERTIES"			"0..1"
// STATIC:	"DETAILTEXTURE"				"0..1"
// STATIC:	"PARALLAXINTERVAL"			"0..0"
// STATIC:	"SHEEN"						"0..0"
// STATIC:	"WRINKLEMAPPING"			"0..0"
// STATIC:	"BENTNORMALS"				"0..0"
// STATIC:	"SSS"						"0..0"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"
// DYNAMIC: "FLASHLIGHTSHADOWS"         "0..1"
// DYNAMIC: "NUM_LIGHTS"                "0..4"
// DYNAMIC: "LIGHTMAPPED_MODEL"			"0..0"

// Set to 0 if you are NOT on ACROHS
// DYNAMIC: "CASCADED_SHADOW"			"0..0"

// No Emission = No Emission(?)
// SKIP:	$FLASHLIGHT				&&	$EMISSION
// Selfilluminating Cloth? Bioluminescent Fabric??
// SKIP:	$EMISSION				&&	$SHEEN
// All our glowing materials are >525°C. They cannot be wet. ( Incandescence )
// Water touching the emissive materials would instantly vaporize ( and an explosion occuros )
// Therefore we removed this combo. For the safety of the player. ( Its unlikely to happen because rocks don't glow )
// SKIP:	$EMISSION				&&	$SPECIALPROPERTIES
// Bees don't glow... Or do they and we just don't know(?)
// SKIP:	$EMISSION				&&	$HULLSHELL
// We require the Detail_Texture Sampler for our VectorLayering, the constants too.
// SKIP:	$SPECIALPROPERTIES		&&	$DETAILTEXTURE

// Can't use both of these at the same time for simplicity.
// SKIP:	$PARALLAXINTERVAL		&&	$SHEEN
// SKIP:	$PARALLAXINTERVAL		&&	$HULLSHELL
// SKIP:	$PARALLAXINTERVAL		&&	$WRINKLEMAPPING
// SKIP:	$SHEEN					&&	$HULLSHELL
// I mean yes... Fabric has wrinkles but like... no?
// SKIP:	$SHEEN					&&	$WRINKLEMAPPING

// SKIP: $CASCADED_SHADOW && $FLASHLIGHT
// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)
// We don't care about flashlight depth unless the flashlight is on
// SKIP: ( $FLASHLIGHT == 0 ) && ( $FLASHLIGHTSHADOWS == 1 )

// SKIP: $LIGHTMAPPED_MODEL && $SPECIALPROPERTIES

// This is used to disable features automatically.
#include "ACROHS_Defines.h"

// This IS a Shader used on BRUSHES
#define MODEL

// This Shaders USES Normalmaps
#define NORMALTEXTURE

// This should enable Envmapping behaviour.
#define ENVMAPMODE 1

//	This has to be included first. It includes pragmas, #define's, and the register map.
#include "lux_common_ps_fxc.h"
// SelfIllum Data
#include "lux_common_selfillum.h"
// EnvMapping Data
#include "lux_common_envmap.h"
// common flashlight function.
#include "lux_common_flashlight.h"

#if PARALLAXINTERVAL
#include "lux_common_parallax.h"
#endif

#include "pbr_combined_functions.h"

#define			bAlphaBlend					Bools[0]
sampler			Sampler_EnvMapNew			: register(s10);

struct PS_INPUT
{
    float4	BaseDetailTexCoord		:	TEXCOORD0;
	float4	NormalEMMTexCoord		:	TEXCOORD1;
	float3	WorldNormal				:	TEXCOORD2;
	float3	WorldPos				:	TEXCOORD3;
	float3	ProjPos					:	TEXCOORD4;
	float4	LightmapTexCoord1And2	:	TEXCOORD5; // Explanation : .xy = bHasLightMapUVs ? LightMapUVs : BaseTextureUVs; We check this on the Vertexshader!
	float4	LightAtten				:	TEXCOORD6;
};

struct PS_ALPHABLEND_OUTPUT
{
	float main  : COLOR0;
	float4 vActual : SV_Target1;
};

// Entry point
float4 main(PS_INPUT i) : COLOR
{
	//	Getting our PS_INPUT... TODO/FIXME: Does this require more memory?
	//===========================================================================//
	// Integer Constants are for use with loops only...
	int iDetailBlendMode = trunc(f1DetailBlendMode);
	int iDebug			 = trunc(g_VariousControls1.x);
	float LOD			 = g_VariousControls1.y;

	// int g_Debug = trunc(DEBUG.x);

	float3 f3BaseTextureUV = float3(i.BaseDetailTexCoord.xy, 0.0f);

	// Always need it.
	float3 f3NormalUV =  float3(i.NormalEMMTexCoord.xy, 0.0f);

	#if DETAILTEXTURE
	float3 f3DetailTextureUV = float3(i.BaseDetailTexCoord.zw, 0.0f);
	#endif

	// .xyz's in case we need to pack something later
	float3 f3WorldPosition		= i.WorldPos.xyz;
	float3 f3ProjectPosition	= i.ProjPos.xyz;
	float2 f2LightmapUV			= i.LightmapTexCoord1And2.xy;

	// ShiroDkxtro2 :	We do this like the PBR Shader.
	//					Tottery says this causes issues on smoothed models.
	//					However, it means we can receive more things from the Vertex Shader
	//					And I have not noticed any of such Issues.
	float3 f3FaceNormal = normalize(i.WorldNormal);
	float3 f3WorldNormal = f3FaceNormal;
    float3 f3SurfaceTangent;
    float3 f3SurfaceBase; 
    float f1FlipSign;
    float3x3 f3x3NormalBasis = Compute_Tangent_Frame(f3FaceNormal, f3WorldPosition, f3NormalUV.xy , f3SurfaceTangent, f3SurfaceBase, f1FlipSign);
	float3	f3ViewVector = normalize(g_EyePos.xyz - f3WorldPosition); // Lo
	
//////////////////////////////////////////////////////////////////////////////////////////
//								PARALLAX INTERVAL MAPPING								//
//////////////////////////////////////////////////////////////////////////////////////////
//	f1ParallaxHeight	
//	f1ParallaxMaxOffset	
//	f1ParallaxIntensity	
//	f1ParallaxInterval
#if PARALLAXINTERVAL
	float3 f3RelativeViewDirection	=	float3(	dot(f3ViewVector, f3SurfaceTangent),	dot(f3ViewVector, f3SurfaceBase),	dot(f3ViewVector, f3FaceNormal));

// Calculate the height at the current UV coordinate
float fCurrentHeight = tex2D(Sampler_NormalTexture, f3BaseTextureUV.xy).w * f1ParallaxIntensity;

// Calculate the parallax offset
float fParallaxOffset = 0;
int iParallaxCounter = 0;
while(iParallaxCounter < INTERVAL_COUNT)
{
	iParallaxCounter++;
    // Calculate the interval height and maximum offset
    fCurrentIntervalHeight = iParallaxCounter * fIntervalSize;
    fCurrentIntervalMaxOffset = fCurrentIntervalHeight * f1ParallaxMaxOffset / f1ParallaxHeight;

    // Calculate the intersection point of the view direction with the interval plane
    float2 f2IntersectionPoint = f3BaseTextureUV.xy + f3RelativeViewDirection.xy * fParallaxOffset;

    // Calculate the height at the intersection point
    float fIntersectionHeight = tex2D(Sampler_NormalTexture, f2IntersectionPoint.xy).w * f1ParallaxIntensity;

    // Determine if we need to continue the loop
    if (fIntersectionHeight > fCurrentIntervalHeight)
    {
        // Calculate the offset for the current interval
        float fCurrentOffset = (fIntersectionHeight - fCurrentIntervalHeight) / (fIntersectionHeight - fPreviousIntervalMaxOffset);
        fParallaxOffset += fCurrentIntervalMaxOffset * fCurrentOffset;

        // Save the previous interval's maximum offset
        fPreviousIntervalMaxOffset = fCurrentIntervalMaxOffset;
    }
    else
    {
        // Exit the loop if the intersection point is below the current interval
        break;
    }
}

// Calculate the parallax-corrected texture coordinates
float2	f2ParallaxOffset		=	f3ViewDirection.xy * fParallaxOffset;
		f3BaseTextureUV.xy		+=	f2ParallaxOffset;
		f3NormalUV.xy			+=	f2ParallaxOffset;
	#if DETAILTEXTURE
		f3DetailTextureUV.xy	+=	f2ParallaxOffset;
	#endif
#endif

	//===========================================================================//
	//	Getting the current Pixels Color from the Samplers
	//===========================================================================//

	float4	f4BaseTexture		=	tex2D(Sampler_BaseTexture, f3BaseTextureUV.xy);	
	float4	f4NormalTexture		=	tex2D(Sampler_NormalTexture, f3NormalUV.xy);	
	float4	f4MRAO				=	tex2D(Sampler_MRAO, f3BaseTextureUV.xy);
	f4BaseTexture.xyz		   *=	f3BaseTextureTint;

	// Set up MRAO terms :
			f4MRAO.x			=	clamp(f4MRAO.x + f1MetallicBias	   ,0.0f ,1.0f); // evil leveling
			f4MRAO.y			=	clamp(f4MRAO.y + f1RoughnessBias   ,0.0f ,1.0f); // evil leveling
			f4MRAO.z			=	clamp(f4MRAO.z + f1AOBias		   ,0.0f ,1.0f); // evil leveling
	float	f1Metalness			=	f4MRAO.x;
	float	f1Roughness			=	f4MRAO.y;
	float	f1AmbientOcclusion	=	f4MRAO.z;
	float3	f3Specular			=	lerp(f1DiElectricCoefficient.xxx, f4BaseTexture.rgb, f1Metalness); // ( DiElectricCoefficient  default is 0.025 now )
	float3	f3Albedo			=	f4BaseTexture.xyz * ( 1.0f - f1Metalness );
//			f3Albedo		   *=	PI; // 3.141593. Rounded up
//	Wetness And Porisity modifaction for input textures.
//	Adapted from Uncharted TechArt pdf
//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
//	VectorLayer is our own implementation!
#if SPECIALPROPERTIES

// FIXME:	f4NormalTexture.xy is probably calculated incorrectly.
//			In the pdf they do float2 but this kind of implies they only want to modify two components... doesn't it?

float4	f4PropertiesTexture		=	tex2D(Sampler_Properties , f3BaseTextureUV.xy);
float	f1Wetness				=	f4PropertiesTexture.x;
float	f1Porosity				=	f4PropertiesTexture.y;
float	f1VectorBlendMask		=	f4PropertiesTexture.z;
float	f1VectorLayerRoughness	=	f4PropertiesTexture.w;
float4	f4VectorLayerTexture	=	tex2D(Sampler_VectorLayer , f3BaseTextureUV.xy); // Uses the same sampler as the detailtexture
float3	f3VectorLayerTexture	=	f4VectorLayerTexture.xyz;
float	f1VectorLayerAO			=	f4VectorLayerTexture.w;
float	f1VectorBlend			=	0.0f;
if(bVectorBlend)
{
	// We clamp the dot at 0. If the Normal and Desired is -1 they will return 1.0f. Otherwise only positive values will persist.
	f1VectorBlend				=	max(0.0f, dot(f3DesiredVector, f3WorldNormal)); // If they are the same. 1.0f, slowly progressing there...
	f1VectorBlend				=	smoothstep(f1VectorLayerFactor, 1.0f, f1VectorBlend); // Only 0.3 difference... Otherwise you will have a smooth falloff... Which we don't want.
	f1VectorBlend				*=	f1VectorBlendMask; // f1VectorLayerFactor = artist input

	f3Albedo					=	lerp(f3Albedo			,f3VectorLayerTexture		, f1VectorBlend);
	f1Roughness					=	lerp(f1Roughness		,f1VectorLayerRoughness		, f1VectorBlend);
	f3Specular					=	lerp(f3Specular			,float3(0.0f, 0.0f, 0.0f)	, f1VectorBlend);
	f1AmbientOcclusion			=	lerp(f1AmbientOcclusion	,f1VectorLayerAO			, f1VectorBlend);
}

if(bWetnessPorosity)
{
		f1Wetness				=	clamp(f1Wetness + f1WetnessBias, 0.0f , 1.0f); // evil leveling
float3	f3SaturatedAlbedo		=	f3Albedo * f3Albedo; // Square
		f3Albedo				=	lerp(f3Albedo			, f3SaturatedAlbedo	, ClampRange(f1Wetness, 0.00f, 0.35f) * f1Porosity);
		f1Roughness				=	lerp(f1Roughness		, 0.10f				, ClampRange(f1Wetness, 0.20f, 1.00f));
		f3Specular				=	lerp(f3Specular			, 0.25f				, ClampRange(f1Wetness, 0.25f, 0.50f));
		f1AmbientOcclusion		=	lerp(f1AmbientOcclusion	, 1.00f				, ClampRange(f1Wetness, 0.45f, 0.95f));										
		f4NormalTexture.xy		=	lerp(f4NormalTexture.xy	, float2(0.5f, 0.5f), ClampRange(f1Wetness, 0.45f, 0.95f));
		f3WorldNormal			=	lerp(f3WorldNormal		, float3(0, 0, 1.0f), ClampRange(f1Wetness, 0.98f, 1.00f));
		f3WorldNormal			=	normalize(f3WorldNormal);
}
#endif

	//==============================================================================================================//
	// We want to do the below as late as possible so we can modify everything with wetness/porosity first above.
	//==============================================================================================================//

#if DETAILTEXTURE
	float4	f4DetailTexture	= tex2D(Sampler_DetailTexture, f3DetailTextureUV.xy);
	f4DetailTexture.xyz *= f3DetailTextureTint;
	f3Albedo = TextureCombine( float4(f3Albedo, f4BaseTexture.w), f4DetailTexture, iDetailBlendMode, f1DetailBlendFactor ).xyz;
#endif

	// Important to use WorldNormal. We want actual direction of the surface, and not fake one.
		float	f1NdotV				=	max( dot( f3WorldNormal, f3ViewVector ), 0.0f ); // cosLo

	//	AO Fresnel. ( AO should not appear when viewing from the front. )
	//	AO happens when a pixel is occluded by nearby geometry. This is not the case when you look at it from the front.
	//	https://advances.realtimerendering.com/other/2016/naughty_dog/NaughtyDog_TechArt_Final.pdf
			f1AmbientOcclusion	=	lerp(1.0f, f1AmbientOcclusion, f1NdotV);
	float3	f3NormalTexture		=	normalize((f4NormalTexture.xyz * 2.0f - 1.0f ) * 2.0f); // Perturbed Normals
	// Merge Facenormal and Normalmap together for reflection vector etc.
			f3FaceNormal		=	normalize(mul(f3NormalTexture, f3x3NormalBasis));

    // Prepare ambient and direct
    float3 f3AmbientLighting = 0.0f;
    float3 f3DirectLighting = 0.0f;

#if SSS
	float4	f4SSSTexture  = tex2D(Sampler_SSS, f3BaseTextureUV.xy);
	// Actual color is on yzw. That way when there is no blue we can use compressed image formats.
	// Especially nice for BGR565 and DXT because Red is used on most SSS Materials, and that way it gets least compression.
			f4SSSTexture.yzw *= f3SSSTint;
#endif

#if EMISSION
	float3 f3EmissionTexture = tex2D(Sampler_Emission, f3BaseTextureUV.xy).xyz * f3EmissionTint;
	#if SSS
	f3EmissionTexture *= (1.0f - f1SSSEmission); // Don't want to have Emission when SSSEmission exists
	#endif
#else
	float3 f3EmissionTexture = float3(0,0,0); // Dummy for SSS Function
#endif

#if !FLASHLIGHT
	//	We do cubemap ambient cubes because there is no ambient cubes for static props. That way we could also use this on brushes and make things look somewhat consistent.
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, Sampler_EnvironmentMap); // Sampler_EnvMapNew    

	// A better reflection vector...
	float3 f3ReflectionVector = 2.0 * f1NdotV * f3FaceNormal - f3ViewVector;

	// Lookup the Texture using f3ReflectionVector as the VectorUV for the Cubemap. ( which pixel it points at)
    float4 f4SpecularUV = float4(f3ReflectionVector, f1Roughness * LOD); // ENVMAPLOD
	float3 f3SpecularLookUp = ENV_MAP_SCALE * texCUBElod(Sampler_EnvironmentMap, f4SpecularUV).xyz; // Sampler_EnvMapNew    Sampler_EnvironmentMap

	#if BENTNORMALS
		// Lookup Ambient by the Bent Normal, instead of reflection vector.
		float3	f3BentNormal		= tex2D(Sampler_BentNormal, f3NormalUV.xy).xyz;
		float3	f3LookupLow			= AmbientLight(f4SpecularUV.xyz, EnvAmbientCube); // f3NormalTexture
		float	f1ReflectOcclusion	=	max(dot(f4SpecularUV.xyz, f3BentNormal), 0);

		// Attenuate the occlusion factor by the ambient occlusion.
		// This is important because we only want to attenuate reflections in areas where they COULD be.
		// If we didn't do this, reflections will be attenuated in open areas, which they shouldn't.
			f1ReflectOcclusion	=	lerp(f1ReflectOcclusion, 1.0f, f1AmbientOcclusion);

		// Apply Reflection Occlusion.
		f3LookupLow			*= f1ReflectOcclusion;
		f3SpecularLookUp	*= f1ReflectOcclusion;
	#else
		float3 f3LookupLow = AmbientLight(f4SpecularUV.xyz, EnvAmbientCube);
	#endif

	f3SpecularLookUp *= f3EnvMapTint;
	float3 f3LookupHighSaturated = f3SpecularLookUp * f3SpecularLookUp;
	f3SpecularLookUp = lerp( f3SpecularLookUp, f3LookupHighSaturated, f1EnvMapContrast );

	// If you are curious this has to do with perception.
	float3 f3DesaturatedCubemap = dot( f3SpecularLookUp, f3LumCoefficients );
	f3SpecularLookUp = lerp( f3DesaturatedCubemap, f3SpecularLookUp, f3EnvMapSaturation );

    float3 f3SpecularIrradiance = lerp(f3SpecularLookUp, f3LookupLow, f1Roughness * f1Roughness);
    float3 f3SpecularIBL = f3SpecularIrradiance * EnvBRDFApprox(f3Specular, f1Roughness, f1NdotV);

//	f3SpecularIBL = UnrealDiffuseIBL(f3SpecularIBL, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, float3(1,1,1), float3(1,1,1));
	float f1SpecularFresnel = 1.0f - FresnelRoughness(f1NdotV, f3Specular, f1Roughness);
	f3SpecularIBL *= f1SpecularFresnel;
// StaticUnrealDiffuseIBL(f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3SpecularIBL);

    // End ambient

    // Start direct
	// Lightmapped model should only have NUM_LIGHTS for named lights!
	// That way you can have bumped lighting from non static lightsources!
	// Information from Static Light sources is already baked into the lightmap.
	// If you want the "funny phong reflections" you must use bumped lightmaps, and that requires a heavily custom compiler.
	float	f1aLightAttenuations[4] = {0.0, 0.0, 0.0, 0.0};
			f1aLightAttenuations[0] = i.LightAtten.x;
			f1aLightAttenuations[1] = i.LightAtten.y;
			f1aLightAttenuations[2] = i.LightAtten.z;
			f1aLightAttenuations[3] = i.LightAtten.w;

//	[unroll] // Tell the compiler to forcibly unroll this.
    for (int i = 0; i < NUM_LIGHTS; i++)
    {
		float3	f3LightIn = float3(0,0,0);
		float3	f3LightColor = float3(0,0,0);
		if ( i == 3 ) // I wonder if the compiler can unroll this... mhm
		{
			// Unpack light 3 from w components...
			f3LightColor = float3( cLightInfo[0].color.w, cLightInfo[0].pos.w, cLightInfo[1].color.w );
			f3LightIn = normalize( float3( cLightInfo[1].pos.w, cLightInfo[2].color.w, cLightInfo[2].pos.w ) - f3WorldPosition);
		}
		else
		{
			f3LightColor = cLightInfo[i].color.rgb;
			f3LightIn = normalize( cLightInfo[i].pos - f3WorldPosition);
		}

		// This has to be done before PBR_ComputeLight because we want the unmodified LightColor
	#if SSS
		f3DirectLighting += ComputeSSSLight(f3LightIn, f3FaceNormal, f3ViewVector, f1aLightAttenuations[i], f4SSSTexture, f3LightColor , f3EmissionTexture, f3EmissionTexture);
	#endif

		f3LightColor =	PBR_ComputeLight(f3LightIn, f3WorldPosition, f3FaceNormal, f3LightColor);		

	#if SHEEN
			f3LightColor = SheenDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3LightIn, f3LightColor) * f1SheenScale * f1aLightAttenuations[i];
	#else
			f3LightColor = UnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3LightIn, f3LightColor) * f1aLightAttenuations[i];
	#endif
		// Apply Shadows and Microshadows to the desired amount. 
			f3DirectLighting += f3LightColor * lerp(1.0f, ApplyMicroShadows(f1AmbientOcclusion, f3FaceNormal, f3LightIn), g_VariousControls1.z) ;	 // f3LightColor;
    }

// Lightmap_Sampler == Properties Sampler
#if LIGHTMAPPED_MODEL
// If the model is lightmapped, we draw lighting from the texture.
	float3	f3DiffuseIBL = StaticUnrealDiffuseIBL(f3Specular, f1Roughness, f1NdotV, f3FaceNormal, tex2D(Sampler_LightMap, f2LightmapUV).xyz * 2.0f);
	f3SpecularIBL = lerp(f3SpecularIBL, f3SpecularIBL * saturate(f3DiffuseIBL), f1EnvMapLightScale);
	f3AmbientLighting = (f3DiffuseIBL + f3SpecularIBL) * f1AmbientOcclusion;
#else
// $EnvMapLightScale
	f3SpecularIBL = lerp(f3SpecularIBL, f3SpecularIBL * saturate(f3DirectLighting), f1EnvMapLightScale);
	f3AmbientLighting = f3SpecularIBL * f1AmbientOcclusion;
#endif

	// Thank you Blizzard / Activision
	// Specular Occlusion.
	// Occludes at grazing angles, assumes isotropic occlusion.
	// This.. Doesn't really change anything...?
	/*
	static const float f1SpecularPow = 8.0f;
	float	f1SpecularOcclusion	= saturate(-0.3 + f1NdotV * f1NdotV);
			f1SpecularOcclusion	= lerp(pow(f1AmbientOcclusion, f1SpecularPow), 1.0f, f1SpecularOcclusion);
	f3SpecularIBL *= f1SpecularOcclusion;
	*/

#else  // End direct

// TODO: Pack this into a neat little function inside our Header.
	float4 f4FlashlightSpacePosition = mul(float4(f3WorldPosition, 1.0), g_FlashlightWorldToTexture);
	clip(f4FlashlightSpacePosition.w);

	float3 f3ProjCoords = f4FlashlightSpacePosition.xyz / f4FlashlightSpacePosition.w;

	float3 f3FlashlightColor = tex2D(Sampler_FlashlightCookie, f3ProjCoords.xy).xyz;

	// Removed some ifdef for Shadermodels here.
	f3FlashlightColor *= cFlashlightColor.xyz;

	float3	f3Delta = g_FlashlightPos.xyz - f3WorldPosition;
	float3	f3L = normalize(f3Delta);
	float	f1DistSquared = dot(f3Delta, f3Delta);
	float	f1Dist = sqrt(f1DistSquared);

	float	f1FarZ = g_FlashlightAttenuationFactors.w;
	float	f1EndFalloffFactor = RemapValClamped(f1Dist, f1FarZ, 0.6f * f1FarZ, 0.0f, 1.0f);

	// Attenuation for light and to fade out shadow over distance
	float	f1Atten = saturate(dot(g_FlashlightAttenuationFactors.xyz, float3(1.0f, 1.0f / f1Dist, 1.0f / f1DistSquared)));

#if FLASHLIGHTSHADOWS
		// TODO: Figure out if this was set to 2048 because of forced Shadow Resolution or because its good values...
		float f1Shadow = LUX_DoShadowNvidiaPCF5x5Gaussian(f3ProjCoords, float2(1.0 / 2048.0, 1.0 / 2048.0));
		float f1Attenuated = lerp(saturate(f1Shadow), 1.0f, g_ShadowTweaks.y);	// Blend between fully attenuated and not attenuated
		
		f1Shadow = saturate(lerp(f1Attenuated, f1Shadow, f1Atten));	// Blend between shadow and above, according to light attenuation
		f3FlashlightColor *= f1Shadow;									// Shadow term
#endif

	float3 f3DiffuseLighting = f1Atten;
	f3DiffuseLighting *= saturate(dot(f3L.xyz, f3FaceNormal) + f1FlashlightNoLambertValue); // NoLambertValue is either 0 or 2
	
	f3DiffuseLighting *= f3FlashlightColor;
	f3DiffuseLighting *= f1EndFalloffFactor;

	#if SSS
		f3DirectLighting += ComputeSSSLight(f3L, f3FaceNormal, f3ViewVector, 1.0f, f4SSSTexture, f3DiffuseLighting, f3EmissionTexture, f3EmissionTexture);
	#endif

	#if SHEEN
		f3DirectLighting += SheenDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3L, f3DiffuseLighting);
	#else
		f3DirectLighting += UnrealDiffuseIBL(f3Albedo, f3Specular, f1Roughness, f3ViewVector, f3FaceNormal, f3L, f3DiffuseLighting);
	#endif

#endif // !FLASHLIGHT

    float f1FogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, f3WorldPosition, f3ProjectPosition.z);

#if !FLASHLIGHT
#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    float f1Alpha = f1FogFactor;
#else
    float f1Alpha = f4BaseTexture.a;
#endif // WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
#else
    float f1Alpha = 0.0f;
#endif // !FLASHLIGHT

    bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

	// Combine the results
	float4 f4Result = float4(f3EmissionTexture + f3DirectLighting + f3AmbientLighting ,f1Alpha);

#if DETAILTEXTURE
	f4Result.xyz = TextureCombinePostLighting( f4Result, f4DetailTexture, iDetailBlendMode, f1DetailBlendFactor ); // $detail, $detailblendmode $detailblendfactor
#endif

    return FinalOutput(f4Result, f1FogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, f3ProjectPosition.z);
}

